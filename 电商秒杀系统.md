---
typora-root-url: ..\typicture
---

# 电商秒杀系统

## 基础介绍

### 所用技术

![image-20210606203626980](https://github.com/Chi-hw/kill/tree/main/%E7%94%B5%E5%95%86%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F.assets/image-20210606203626980.png)

### 主要方案

![image-20210606204232117](https://github.com/Chi-hw/kill/tree/main/%E7%94%B5%E5%95%86%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F.assets/image-20210606204232117.png)

### 如何设计一个秒杀系统

**主要解决两个问题：一个是并发读，一个是并发写**

并发读的核心优化理念是尽量减少用户到服务端来“读数据”，或让他们读更少的数据。并发写的处理原则也一样，要求我们在数据库层面独立出来一个库，做特殊的处理，另外，还要针对秒杀系统做一些保护，针对意料之外的情况设计方案来兜底，防止最坏情况发生

**秒杀整体架构概况为”稳、准、快“**

整个系统结构要满足高可用，流量复合预期时要稳定，超出预期也不能出问题，要保证秒杀活动顺利完成，即秒杀的商品顺利卖出

秒杀多少货物就成交多少货物，不能多也不能少，要保证数据的一致性

系统的性能要足够高，以支撑大流量并发访问，服务端要做性能优化，整个请求链路上都要做协同的优化，合力使系统更完美

技术角度的”稳、准、快“，对应了架构上的高可用、一致性和高性能的要求

- **高性能**：秒杀涉及大量并发读和并发写，支持高并发访问非常关键。对应方案如动静分离方案，热点的发现与隔离、请求削峰与分层过滤、服务端的优化
- **一致性**：秒杀中商品库存的实现方式同样关键，有限商品在同一时刻被很多倍的请求同时来减库存，减库存又分为”拍下减库存“”付款减库存“”预扣“等，大并发更新过程中都要保证数据的准确性
- **高可用**：保证系统的高可用和正确性，设计备用方案，应对突发事件

## 项目搭建

构建springboot项目，选用spring Web，Themyleaf模板，Mysql  Driver，Lombok  四个依赖构建项目

配置pom文件添加[MybatisPlus依赖](https://mp.baomidou.com/guide/install.html#release)

再配置属性类

```java
#thymeleaf配置，关闭缓存
spring.thymeleaf.cache=false
#数据源配置
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3306/kill?serverTimezone=UTC
spring.datasource.username=root
spring.datasource.password=orcl
#连接池名
spring.datasource.hikari.pool-name=DateHikariCP
#最小空闲连接数
spring.datasource.hikari.minimum-idle=5
#空闲连接存活最大时间，默认60000（10分钟）
spring.datasource.hikari.idle-timeout=180000
#最大连接数，默认10
spring.datasource.hikari.maximum-pool-size=10
#从连接池返回的连接自动提交
spring.datasource.hikari.auto-commit=true
#连接最大存活时间，0表示永久存活，默认180000（30分钟）
spring.datasource.hikari.max-lifetime=180000
#连接超时时间，默认30000（30）秒
spring.datasource.hikari.connection-timeout=30000
#测试连接是否可用的查询语句
spring.datasource.hikari.connection-test-query=SELECT 1

#Mybatis-plus配置Mapper.xml映射文件
mybatis-plus.mapper-locations=classpath*:/mapper/*Mapper.xml
#配置Mybatis数据返回类型别名（默认别名是类名）
mybatis-plus.type-aliases-package=com.chw.kill.domain

#Mybatis SQL 打印（方法接口所在的包，不是Mapper.xml所在的包）
logging.level.com.chw.kill.mapper:debug
```

在resource下新建mapper文件，在java下建立所需的类

![image-20210607184921839](/../kill/pictures/image-20210607184921839.png)

测试是否搭建成功

```java
@SpringBootApplication
@MapperScan("com.chw.kill.domain")
public class KillApplication {
    public static void main(String[] args) {
        SpringApplication.run(KillApplication.class, args);
    }
}
```

```java
@Controller
public class damocontroller {

    @RequestMapping("/")
    public String home(Model model) {
        model.addAttribute("name","world");
        return "test";
    }
}
```

```html
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>测试</title>
</head>
<body>
<p th:text="'hello'+${name}"></p>
</body>
</html>
```

![image-20210607185128255](/../kill/pictures/image-20210607185128255.png)

## 分布式会话

### 实现登录

#### 两次MD5加密

- 用户端：PASS=MD5（明文+固定Salt）防止用户密码在网络中明文传输
- 服务端：PASS=MD5（用户输入+随机Salt）提高密码安全性，双重保险

引入相关md5依赖

```java
<!--md5 依赖-->
<dependency>
    <groupId>commons-codec</groupId>
    <artifactId>commons-codec</artifactId>
</dependency>
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-lang3</artifactId>
    <version>3.6</version>
</dependency>
```

建立Utils.MD5Util.java ，MD5工具类

#### 构建逆向工程

数据库中构建表

```mysql
CREATE TABLE `t_user` (
  `id` bigint(20) unsigned NOT NULL COMMENT '用户id,手机号码',
  `nickname` varchar(255) NOT NULL COMMENT '昵称',
  `password` varchar(32) DEFAULT NULL COMMENT 'MD5(MD5(pass明文+固定salt)+salt)',
  `salt` varchar(10) DEFAULT NULL COMMENT '盐',
  `head` varchar(128) DEFAULT NULL COMMENT '头像',
  `register_date` datetime DEFAULT NULL COMMENT '注册时间',
  `last_login_date` datetime DEFAULT NULL COMMENT '最后一次登录时间',
  `login_count` int(11) DEFAULT NULL COMMENT '登录次数',
  PRIMARY KEY (`id`)
) ;
```

新建springboot项目，只用springWeb

![image-20210607211053948](/../kill/pictures/image-20210607211053948.png)

需要手动添加的依赖

```java
<!--mybatisplus组件-->
<dependency>
    <groupId>com.baomidou</groupId>
    <artifactId>mybatis-plus-boot-starter</artifactId>
    <version>3.4.3</version>
</dependency>
<!--代码生成器依赖-->
<dependency>
    <groupId>com.baomidou</groupId>
    <artifactId>mybatis-plus-generator</artifactId>
    <version>3.4.1</version>
</dependency>
<!--freemarker模板引擎-->
<dependency>
    <groupId>org.freemarker</groupId>
    <artifactId>freemarker</artifactId>
    <version>2.3.30</version>
</dependency>
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <scope>runtime</scope><!--运行时才会生效-->
</dependency>
```

逆向工程代码生成器（官网）

```java
package com.chw.generator;

import com.baomidou.mybatisplus.core.exceptions.MybatisPlusException;
import com.baomidou.mybatisplus.core.toolkit.StringPool;
import com.baomidou.mybatisplus.core.toolkit.StringUtils;
import com.baomidou.mybatisplus.generator.AutoGenerator;
import com.baomidou.mybatisplus.generator.InjectionConfig;
import com.baomidou.mybatisplus.generator.config.*;
import com.baomidou.mybatisplus.generator.config.po.TableInfo;
import com.baomidou.mybatisplus.generator.config.rules.DateType;
import com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;
import com.baomidou.mybatisplus.generator.engine.FreemarkerTemplateEngine;

import java.util.*;

/**
 * @Author Chihw
 * @Description
 * @Date 2021/6/7 20:32
 */
// 演示例子，执行 main 方法控制台输入模块表名回车自动生成对应项目目录中
public class CodeGenerator {

    /**
     * <p>
     * 读取控制台内容
     * </p>
     */
    public static String scanner(String tip) {
        Scanner scanner = new Scanner(System.in);
        StringBuilder help = new StringBuilder();
        help.append("请输入" + tip + "：");
        System.out.println(help.toString());
        if (scanner.hasNext()) {
            String ipt = scanner.next();
            if (StringUtils.isNotBlank(ipt)) {
                return ipt;
            }
        }
        throw new MybatisPlusException("请输入正确的" + tip + "！");
    }

    public static void main(String[] args) {
        // 代码生成器
        AutoGenerator mpg = new AutoGenerator();

        // 全局配置
        GlobalConfig gc = new GlobalConfig();
        String projectPath = System.getProperty("user.dir");
        gc.setOutputDir(projectPath + "/src/main/java");
        //作者
        gc.setAuthor("chw");
        //是否打开输出目录
        gc.setOpen(false);
        //xml开启BaseResultMap
        gc.setBaseResultMap(true);
        //xml开启BaseColumnList
        gc.setBaseColumnList(true);
        //日期格式，采用Date
        gc.setDateType(DateType.ONLY_DATE);
        // gc.setSwagger2(true); 实体属性 Swagger2 注解
        mpg.setGlobalConfig(gc);

        // 数据源配置
        DataSourceConfig dsc = new DataSourceConfig();
        dsc.setUrl("jdbc:mysql://localhost:3306/kill?useUnicode=true&useSSL=false&characterEncoding=utf8&serverTimezone=UTC");
        // dsc.setSchemaName("public");
        dsc.setDriverName("com.mysql.cj.jdbc.Driver");
        dsc.setUsername("root");
        dsc.setPassword("password");
        mpg.setDataSource(dsc);

        // 包配置
        PackageConfig pc = new PackageConfig();
        //pc.setModuleName(scanner("模块名"));
        pc.setParent("com.xxx.kill")
            .setEntity("domain")
            .setMapper("mapper")
            .setService("service")
            .setServiceImpl("service.impl")
            .setController("controller");
        mpg.setPackageInfo(pc);

        // 自定义配置
        InjectionConfig cfg = new InjectionConfig() {
            @Override
            public void initMap() {
                // to do nothing
                Map<String,Object> map=new HashMap<>();
                map.put("data1","1.0.0");
                this.setMap(map);
            }
        };

        // 如果模板引擎是 freemarker
        String templatePath = "/templates/mapper.xml.ftl";
        // 如果模板引擎是 velocity
        // String templatePath = "/templates/mapper.xml.vm";

        // 自定义输出配置
        List<FileOutConfig> focList = new ArrayList<>();
        // 自定义配置会被优先输出
        focList.add(new FileOutConfig(templatePath) {
            @Override
            public String outputFile(TableInfo tableInfo) {
                // 自定义输出文件名 ， 如果你 Entity 设置了前后缀、此处注意 xml 的名称会跟着发生变化！！
                //+ pc.getModuleName() + "/"
                return projectPath + "/src/main/resources/mapper/" + tableInfo.getEntityName() + "Mapper" + StringPool.DOT_XML;
            }
        });
        /*
        cfg.setFileCreate(new IFileCreate() {
            @Override
            public boolean isCreate(ConfigBuilder configBuilder, FileType fileType, String filePath) {
                // 判断自定义文件夹是否需要创建
                checkDir("调用默认方法创建的目录，自定义目录用");
                if (fileType == FileType.MAPPER) {
                    // 已经生成 mapper 文件判断存在，不想重新生成返回 false
                    return !new File(filePath).exists();
                }
                // 允许生成模板文件
                return true;
            }
        });
        */
        cfg.setFileOutConfigList(focList);
        mpg.setCfg(cfg);

        // 配置模板
        TemplateConfig templateConfig = new TemplateConfig()
                .setEntity("templates/entity.java")
                .setMapper("templates/mapper.java")
                .setService("templates/service.java")
                .setServiceImpl("templates/serviceImpl.java")
                .setController("templates/controller.java");

        // 配置自定义输出模板
        //指定自定义模板路径，注意不要带上.ftl/.vm, 会根据使用的模板引擎自动识别
        // templateConfig.setEntity("templates/entity2.java");
        // templateConfig.setService();
        // templateConfig.setController();

        templateConfig.setXml(null);
        mpg.setTemplate(templateConfig);

        // 策略配置
        StrategyConfig strategy = new StrategyConfig();
        //数据库表映射到实体的命名策略 ，驼峰命名
        strategy.setNaming(NamingStrategy.underline_to_camel);
        //数据库表字段映射到实体的命名策略 ，驼峰命名
        strategy.setColumnNaming(NamingStrategy.underline_to_camel);
        //lombok模型
        strategy.setEntityLombokModel(true);
        //生成@RestController控制器
        //strategy.setControllerMappingHyphenStyle(true);

        /*strategy.setSuperEntityClass("你自己的父类实体,没有就不用设置!");
        strategy.setEntityLombokModel(true);
        strategy.setRestControllerStyle(true);
        // 公共父类
        strategy.setSuperControllerClass("你自己的父类控制器,没有就不用设置!");
        // 写于父类中的公共字段
        strategy.setSuperEntityColumns("id");*/
        strategy.setInclude(scanner("表名，多个英文逗号分割").split(","));
        strategy.setControllerMappingHyphenStyle(true);
        //表前缀
        //strategy.setTablePrefix(pc.getModuleName() + "_");
        strategy.setTablePrefix("t_");
        mpg.setStrategy(strategy);
        mpg.setTemplateEngine(new FreemarkerTemplateEngine());
        mpg.execute();
    }

}
```

运行CodeGenerator.java文件

输入表名t_user。在项目中生成相关controller、domain、service等，逆向工程生成的类不一定用到，后期可以删除

#### 准备工作

下载启用Lombok插件。

设置跳转登录路径，

```
@RequestMapping("/toLogin")
public String toLogin(){
    return "login";
}
```

处理前端页面

设置公共返回对象

```java
package com.chw.kill.result;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * @Author Chihw
 * @Description 公共返回对象
 * @Date 2021/6/7 21:28
 */
@Data
@NoArgsConstructor //无参构造
@AllArgsConstructor //全参构造
public class RespBean {
    private long code;
    private String message;
    private Object obj;
    /**
     * @Description: 成功返回结果
     * @param: []
     * @return: com.chw.kill.result.RespBean
     * @date: 2021/6/7 21:53
     */
    public static RespBean success(){
        return new RespBean(RespBeanEnum.SUCCESS.getCode(),RespBeanEnum.SUCCESS.getMessage(),null);
    }
    /**
     * @Description: 方法重载，成功返回结果
     * @param: [obj]
     * @return: com.chw.kill.result.RespBean
     * @date: 2021/6/7 21:54
     */
    public static RespBean success(Object obj){
        return new RespBean(RespBeanEnum.SUCCESS.getCode(),RespBeanEnum.SUCCESS.getMessage(),obj);
    }
    /**
     * @Description: 失败返回结果
     * @param: [respBeanEnum]
     * @return: com.chw.kill.result.RespBean
     * @date: 2021/6/7 22:00
     */
    public static RespBean error(RespBeanEnum respBeanEnum){
        return new RespBean(respBeanEnum.ERROR.getCode(),respBeanEnum.ERROR.getMessage(),null);
    }
    /**
     * @Description: 失败返回结果
     * @param: [respBeanEnum, obj]
     * @return: com.chw.kill.result.RespBean
     * @date: 2021/6/7 22:00
     */
    public static RespBean error(RespBeanEnum respBeanEnum,Object obj){
        return new RespBean(respBeanEnum.ERROR.getCode(),respBeanEnum.ERROR.getMessage(),obj);
    }

}
```

返回对象的枚举类型

```java
package com.chw.kill.result;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.ToString;

/**
 * @Author Chihw
 * @Description
 * @Date 2021/6/7 21:36
 */
@Getter
@ToString
@AllArgsConstructor
public enum RespBeanEnum {
    SUCCESS(200, "SUCCESS"),
    ERROR(500, "服务端异常"),
    LOGIN_ERROR(500210, "请检查用户名或密码"),
    MOBILE_ERROR(500211, "手机号码格式不正确"),
    BIND_ERROR(500212,"参数校验异常");

    private final Integer code;
    private final String message;

}

```

#### 验证登录

```java
/**
 * @Description: 登录功能
 * @param: [loginVo]
 * @return: com.chw.kill.result.RespBean
 * @date: 2021/6/7 22:45
 */
@RequestMapping("/doLogin")
@ResponseBody
public RespBean doLogin(LoginVo loginVo){
    //log.info("{}",loginVo);   //加@Slf4j注解可以直接使用log
    return userService.doLogin(loginVo);

}
```

```java
/**
     * @Description: 登录的接口实现类
     * @param: [loginVo] 登录类
     * @return: com.chw.kill.result.RespBean
     * @date: 2021/6/8 18:41
     */
    @Override
    public RespBean doLogin(LoginVo loginVo) {
        String mobile=loginVo.getMobile();
        String password=loginVo.getPassword();
        //校验用户名和密码是否为空
        if(StringUtils.isEmpty(mobile)||StringUtils.isEmpty(password)){
            return RespBean.error(RespBeanEnum.LOGIN_ERROR);
        }
        //校验手机号是否合法
        if(!ValidatorUtil.isMobile(mobile)){
            return RespBean.error(RespBeanEnum.MOBILE_ERROR);
        }
        //根据手机号获取用户
        User user=userMapper.selectById(mobile);
        if(null==user){
            System.out.println(RespBeanEnum.LOGIN_ERROR.getCode());
            System.out.println(RespBeanEnum.LOGIN_ERROR.getMessage());
            return RespBean.error(RespBeanEnum.LOGIN_ERROR);
        }
        if(!MD5Util.formPassToDBPass(password,user.getSalt()).equals(user.getPassword())){
            System.out.println(RespBeanEnum.LOGIN_ERROR.getCode());
            System.out.println(RespBeanEnum.LOGIN_ERROR.getMessage());
            return RespBean.error(RespBeanEnum.LOGIN_ERROR);
        }
        return RespBean.success();
    }
```

```javascript
//script代码  
function login() {
        //先进行对应校验
        $("#loginForm").validate({
            submitHandler: function (form) {
                doLogin();
            }
        });
    }
    function doLogin() {
//        加载中
        g_showLoading();
        var inputPass = $("#password").val();
        var salt = g_passsword_salt;
        var str = "" + salt.charAt(0) + salt.charAt(2) + inputPass + salt.charAt(5) + salt.charAt(4);
        var password = md5(str);

        $.ajax({
            url: "/login/doLogin",
            type: "POST",
            data: {
                mobile: $("#mobile").val(),
                password: password
            },
            success: function (data) {
                layer.closeAll();
                if (data.code == 200) {
                    layer.msg(data.message);
                    window.location.href = "/goods/to_list";
                } else {
                    layer.msg(data.message);
                }
            },
            error: function () {
                layer.closeAll();
            }
        });
    }
```

### 自定义注解参数校验

参数校验太麻烦，引入validation组件添加参数校验

添加依赖

```java
<!--validation 组件-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-validation</artifactId>
</dependency>
```

```java
/**
 * @Description: 登录功能
 * @param: [loginVo]
 * @return: com.chw.kill.result.RespBean
 * @date: 2021/6/7 22:45
 */
@RequestMapping("/doLogin")
@ResponseBody
public RespBean doLogin(@Valid LoginVo loginVo){
    //log.info("{}",loginVo);   //加@Slf4j注解可以直接使用log
    return userService.doLogin(loginVo);

}
```

```java
@Data
public class LoginVo {
    @NotNull
    @IsMobile(required = true)//默认是true可以不加
    private String mobile;

    @NotNull
    @Length(min=32)
    private String password;
}
```

```java
/**
 * @Author Chihw
 * @Description 自定义手机验证注解
 * @Constraint(
 *         validatedBy = {}
 * )  这里需要一个具体的校验类，所以创建IsMobileValidator类
 * @Date 2021/6/8 18:51
 */

@Target({ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Constraint(
        validatedBy = {IsMobileValidator.class}
)
public @interface IsMobile {
    //要求手机号码必填
    boolean required() default true;

    String message() default "手机号码格式错误";

    Class<?>[] groups() default {};

    Class<? extends Payload>[] payload() default {};

}
```

```java
/**
 * @Author Chihw
 * @Description  自定义手机号码校验规则
 * 实现ConstraintValidator< 注解,类型>接口
 * @Date 2021/6/8 18:56
 */
public class IsMobileValidator implements ConstraintValidator<IsMobile,String>{
    private boolean required =false;
    /**
     * @Description: 初始化
     * @param: [constraintAnnotation]
     * @return: void
     * @date: 2021/6/8 19:02
     */
    @Override
    public void initialize(IsMobile constraintAnnotation) {
        required=constraintAnnotation.required();  //获取到填的值
    }
    /**
     * @Description: 校验规则
     * @param: [s, constraintValidatorContext]
     * @return: boolean
     * @date: 2021/6/8 19:05
     */
    @Override
    public boolean isValid(String s, ConstraintValidatorContext constraintValidatorContext) {
        if(required){ //必填
            return ValidatorUtil.isMobile(s);
        }else{        //非必填
            if(StringUtils.isEmpty(s)){
                return true;
            }else{
                return ValidatorUtil.isMobile(s);
            }
        }
    }
}
```

将UserServiceImpl中一部分注释

```java
/*
//校验用户名和密码是否为空
if(StringUtils.isEmpty(mobile)||StringUtils.isEmpty(password)){
    return RespBean.error(RespBeanEnum.LOGIN_ERROR);
}
//校验手机号是否合法
if(!ValidatorUtil.isMobile(mobile)){
    return RespBean.error(RespBeanEnum.MOBILE_ERROR);
}*/
```

启动输入不合法的手机号和密码

```
控制台报错
Resolved [org.springframework.validation.BindException: org.springframework.validation.BeanPropertyBindingResult: 1 errors

Field error in object 'loginVo' on field 'mobile': rejected value [33333333333]; codes [IsMobile.loginVo.mobile,IsMobile.mobile,IsMobile.java.lang.String,IsMobile]; arguments [org.springframework.context.support.DefaultMessageSourceResolvable: codes [loginVo.mobile,mobile]; arguments []; default message [mobile],true]; default message [手机号码格式错误]]
```

捕获绑定的异常(BindException)，抛出对应信息

### 异常处理

validation只能抛出异常，无法前端显示错误信息，进行全局异常处理

springboot全局异常处理有两种方式

- @ControllerAdvice和@ExceptionHandler，@ControllerAdvice只能处理控制器抛出的异常，可以定义多个拦截方法，拦截不同异常，抛出不同异常信息，自由度高
- Error Controller 类  可以处理所有的异常，包括没有进入控制器的异常

建立exception包

```java
/**
 * @Author Chihw
 * @Description 全局异常
 * @Date 2021/6/8 19:31
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class GlobalException extends RuntimeException{
    private RespBeanEnum respBeanEnum;

}
```

```java
/**
 * @Author Chihw
 * @Description 全局异常处理类
 * @Date 2021/6/8 19:32
 */
@RestControllerAdvice  //返回的是ResponseBody,不用在方法上具体返回
public class GlobalExceptionalHandler {
    @ExceptionHandler(Exception.class)
    public RespBean ExceptionHandler(Exception e){
        if(e instanceof GlobalException){
            GlobalException ex= (GlobalException) e;
            return RespBean.error(ex.getRespBeanEnum());
        }else if(e instanceof BindException){
            BindException ex = (BindException) e;
            RespBean respBean=RespBean.error(RespBeanEnum.BIND_ERROR);
            respBean.setMessage("参数校验异常："+ex.getBindingResult().getAllErrors().get(0).getDefaultMessage());
            return respBean;
        }
        return RespBean.error(RespBeanEnum.ERROR);
    }
}
```

修改接口实现类

```java
//根据手机号获取用户
User user=userMapper.selectById(mobile);
if(null==user){
    //return RespBean.error(RespBeanEnum.LOGIN_ERROR);
    throw new GlobalException(RespBeanEnum.LOGIN_ERROR);
}
if(!MD5Util.formPassToDBPass(password,user.getSalt()).equals(user.getPassword())){
    //return RespBean.error(RespBeanEnum.LOGIN_ERROR);
    throw new GlobalException(RespBeanEnum.LOGIN_ERROR);
}
```

### 完善登录

**单一应用没问题，部署分布式会出现分布式session问题，使用两种方法解决，本质是相应信息存到第三方数据库或服务器。**

创建CookieUtil和UUIDUtil

UserServiceImpl登录验证中添加

```java
//生成cookie
String ticket= UUIDUtil.uuid();
request.getSession().setAttribute(ticket,user);
CookieUtil.setCookie(request,response,"userticket",ticket);
```

登录成功，跳转到商品列表页

```java
/**
 * @Description: 商品列表页
 * @param: [session, model, ticket]
 * @return: java.lang.String
 * @date: 2021/6/8 22:09
 */
@RequestMapping("/toList")
public String toList(HttpSession session, Model model, @CookieValue("userticket") String ticket){
    if(StringUtils.isEmpty(ticket)){
        return "login";
    }
    User user = (User) session.getAttribute(ticket);
    System.out.println(user);
    if(null==user){
        return "login";
    }
    model.addAttribute("user",user);
    return "goodsList";
}
```

#### 分布式session问题

![image-20210608223231497](/../kill/pictures/image-20210608223231497.png)

 解决方案

- Session复制
  - 优点
    - 无需修改代码，只需修改Tomcat配置
  - 缺点
    - Session同步传输占用内网带宽
    - 多态Tomcat同步性能指数级下降
    - Session占用内存，无法有效水平扩展
- 前端存储
  - 优点
    - 不占用服务端内存
  - 缺点
    - 存在安全风险
    - 数据大小受cookie限制
    - 占用外网带宽
- Session粘滞
  - 优点
    - 无需修改代码，服务端可以水平扩展
  - 缺点
    - 增加新机器，会重新Hash，导致重新登录
    - 应用重启，需要重新登录
- 后端集中存储
  - 优点
    - 安全，容易水平扩展
  - 缺点
    - 增加复杂度，需要修改代码

方法一：使用spring sessoion实现分布式session

配置依赖

```java
<!--spring data redis 依赖-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
<!--commons-pool2 对象池依赖-->
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-pool2</artifactId>
</dependency>
<--spring session 依赖-->    
<dependency>
    <groupId>org.springframework.session</groupId>
    <artifactId>spring-session-data-redis</artifactId>
    <version>1.3.1.RELEASE </version>
</dependency>
```

添加相应配置

```java
#redis配置
#服务器地址
spring.redis.host=
#端口浩
spring.redis.port=6379
#密码
spring.redis.password=123456
#连接的redis数据库
spring.redis.database=5
#超时时间
spring.redis.timeout=10000ms
#最大连接数，默认8
spring.redis.lettuce.pool.max-active=8
#最大连接阻塞等待时间，默认-1
spring.redis.lettuce.pool.max-wait=10000ms
#最大空闲连接，默认8
spring.redis.lettuce.pool.max-idle=200
#最小空闲连接，默认0
spring.redis.lettuce.pool.min-idle=5
```

启动项目即可实现分布式session

方法二：使用redis实现分布式session

首先删除spring session依赖

建立RedisConfig

```java
package com.chw.kill.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.StringRedisSerializer;

/**
 * @Author Chihw
 * @Description  Redis配置类
 * @Date 2021/6/9 20:13
 */
@Configuration
public class RedisConfig {
    @Bean
    public RedisTemplate<String ,Object> redisTemplate(RedisConnectionFactory redisConnectionFactory){
        RedisTemplate<String,Object> redisTemplate=new RedisTemplate<>();
        //key序列化
        redisTemplate.setKeySerializer(new StringRedisSerializer());
        //value序列化
        redisTemplate.setValueSerializer(new GenericJackson2JsonRedisSerializer());
        //hash类型key序列化
        redisTemplate.setHashKeySerializer(new StringRedisSerializer());
        //hash类型value序列化
        redisTemplate.setHashKeySerializer(new GenericJackson2JsonRedisSerializer());
        //注入连接工厂
        redisTemplate.setConnectionFactory(redisConnectionFactory);
        return redisTemplate;
    }
}
```

登录时将用户信息存入redis，

```java
//将用户信息存入redis中
redisTemplate.opsForValue().set("user:"+ticket,user);
```

由cookie获取用户

```java
/**
 * @Description: 由cookie得到用户信息
 * @param: [userTicket, request, response]
 * @return: com.chw.kill.domain.User
 * @date: 2021/6/9 20:40
 */
@Override
public User getUserByCookie(String userTicket,HttpServletRequest request,HttpServletResponse response) {
   if(StringUtils.isEmpty(userTicket)){
       return null;
   }
   User user= (User) redisTemplate.opsForValue().get("user:"+userTicket);
   if(user!=null){
       CookieUtil.setCookie(request,response,"userticker",userTicket);
   }
    return user;
}
```

#### 优化登录

每一个接口都需要做一次用户的校验，所以自定义用户参数UserArgumentResolver，通过这个参数在每次controller入参之前就完成了参数校验，判断ticket是否为空，判断用户信息，最后传到对应controller里面去，省略校验代码，进一步解耦

```java
/**
 * @Author Chihw
 * @Description  MVC配置类
 * @Date 2021/6/9 21:26
 */
@Configuration
public class WebConfig implements WebMvcConfigurer {
    @Autowired
    private UserArgumentResolever userArgumentResolever;
    @Override
    public void addArgumentResolvers(List<HandlerMethodArgumentResolver> resolvers) {
        resolvers.add(userArgumentResolever);
    }
}
```

```java
/**
 * @Author Chihw
 * @Description  自定义用户参数
 * @Date 2021/6/9 21:59
 */
@Component
public class UserArgumentResolever implements HandlerMethodArgumentResolver {
    @Autowired
    private IUserService userService;
    @Override
    public boolean supportsParameter(MethodParameter methodParameter) {
        Class<?> clazz=methodParameter.getParameterType();
        return clazz== User.class;
    }

    @Override
    public Object resolveArgument(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer, NativeWebRequest nativeWebRequest, WebDataBinderFactory webDataBinderFactory) throws Exception {
        HttpServletRequest request=nativeWebRequest.getNativeRequest(HttpServletRequest.class);
        HttpServletResponse response=nativeWebRequest.getNativeResponse(HttpServletResponse.class);
        String ticket= CookieUtil.getCookieValue(request,"userticket");
        if(StringUtils.isEmpty(ticket)){
            return null;
        }
        return userService.getUserByCookie(ticket,request,response);
    }
}
```

```java
/**
 * @Description: todo
 * @param: [model, user]
 * @return: java.lang.String
 * @date: 2021/6/9 22:25
 */
@RequestMapping("/toList")
public String toList(Model model,User user){
    model.addAttribute("user",user);
    return "goodsList";
}
```

## 秒杀功能

所需要的表

```mysql
CREATE TABLE `t_goods` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '商品ID',
  `goods_name` varchar(30) DEFAULT NULL COMMENT '商品名称',
  `goods_title` varchar(64) DEFAULT NULL COMMENT '商品标题',
  `goods_img` varchar(64) DEFAULT NULL COMMENT '商品图片',
  `goods_detail` longtext COMMENT '商品详情',
  `goods_price` decimal(10,2) DEFAULT NULL,
  `goods_stock` int(11) DEFAULT '0' COMMENT '商品库存，-1表示没有限制',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4;
```

```mysql
CREATE TABLE `t_order` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '订单ID',
	`user_id` bigint(20) DEFAULT NULL COMMENT '用户ID',
  `goods_id` bigint(20) DEFAULT NULL COMMENT '商品ID',
	`deliver_add_id` BIGINT(20) DEFAULT NULL COMMENT '收货地址ID',
  `goods_name` VARCHAR(16) DEFAULT NULL COMMENT '冗余过来的商品名称',
  `goods_count` INT(11) DEFAULT '0' COMMENT '商品数量',
  `goods_price` DECIMAL(10,2) DEFAULT '0.00' COMMENT '商品单价',
	`order_channel` TINYINT(4) DEFAULT '0' COMMENT '1pc,2android,3ios',
	`status` TINYINT(4) DEFAULT '0' COMMENT '订单状态，0新建未支付，1已支付，2已发货，3已收获，4已退款，5已完成',
  `create_date` datetime DEFAULT NULL COMMENT '订单创建时间',
	`pay_date` datetime DEFAULT NULL COMMENT '支付时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=12 DEFAULT CHARSET=utf8mb4;
```

```mysql
CREATE TABLE `t_kill_goods` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '秒杀商品ID',
	`goods_id` bigint(20) DEFAULT NULL COMMENT '商品ID',
	`kill_price` DECIMAL(10,2) DEFAULT '0.00' COMMENT '秒杀价',
  `stock_count` INT(10) DEFAULT NULL COMMENT '库存数量',
	`start_date` datetime DEFAULT NULL COMMENT '秒杀开始时间',
	`end_date` datetime DEFAULT NULL COMMENT '秒杀结束时间',
  PRIMARY KEY (`id`) 
) ENGINE=INNODB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4;
```

```mysql
CREATE TABLE `t_kill_order` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '秒杀订单ID',
	`user_id` bigint(20) DEFAULT NULL COMMENT '用户ID',
  `order_id` bigint(20) DEFAULT NULL COMMENT '订单ID',
  `goods_id` bigint(20) DEFAULT NULL COMMENT '商品ID',
  PRIMARY KEY (`id`) 
) ENGINE=INNODB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4;
```

 正常存储图片要有文件存储服务器，上传后有一个对应的URL，存入URL。

存入的数据

```mysql
INSERT INTO `t_goods` VALUES ('1', 'iphoneX', 'Apple/苹果iPhone X 全网通4G手机苹果X 10', '/img/iphonex.png', 'Apple/苹果iPhone X 全网通4G手机苹果X 10', '7788.00', '100');
INSERT INTO `t_goods` VALUES ('2', '华为 Mate 10', 'Huawei/华为 Mate 10 6G+128G 全网通4G智能手机', '/img/meta10.png', 'Huawei/华为 Mate 10 6G+128G 全网通4G智能手机', '4199.00', '50');
```

```mysql
INSERT INTO `t_kill_goods` VALUES (1, 1, '629', 10, '2021-05-22 17:22:52', '2021-05-22 18:23:00');
INSERT INTO `t_kill_goods` VALUES (2, 2, '939', 10, '2021-05-22 17:22:52', '2021-05-22 18:23:00');
```

### 商品列表展示

进行逆向工程创建属性类，接口，实现类，控制层代码

构建GoodsVo，

```java
package com.chw.kill.vo;

import com.chw.kill.domain.Goods;

import java.math.BigDecimal;
import java.util.Date;

/**
 * @Author Chihw
 * @Description  商品返回对象
 * @Date 2021/6/10 15:27
 */
public class GoodsVo extends Goods {
    private BigDecimal killPrice;
    private Integer stockCount;
    private Date startDate;
    private Date endDate;
}
```

```java
model.addAttribute("goodsList",goodsService.findGoodsVo());
```

```java
@Autowired
private GoodsMapper goodsMapper;

@Override
public List<GoodsVo> findGoodsVo() {
    return goodsMapper.findGoodsVo();
}
```

```java
<select id="findGoodsVo" resultType="com.chw.kill.vo.GoodsVo">
    select
 g.id,g.goods_name,g.goods_title,g.goods_img,g.goods_detail,g.goods_price,g.goods_stock,
 tg.kill_price,tg.stock_count,tg.start_date,tg.end_date
    from
    t_goods g
    left join t_kill_goods tg on g.id=tg.goods_id
</select>
```

```java
/**
 * @Description: 有配置文件又有配置类的情况，配置类优先加载
 * 添加资源的处理器，为了使图片加载
 * @param: [registry]
 * @return: void
 * @date: 2021/6/10 16:08
 */
@Override
public void addResourceHandlers(ResourceHandlerRegistry registry) {
    registry.addResourceHandler("/**").addResourceLocations("classpath:/static/");
}
```

### 商品详情

```java
@RequestMapping("toDetail/{goodsId}")
public String toDetail(Model model,User user, @PathVariable Long goodsId){
    model.addAttribute("user",user);
    model.addAttribute("goods",goodsService.findGoodsVoByGoodsId(goodsId));
    return "goodsDetail";
}
```

```java
@Override
public GoodsVo findGoodsVoByGoodsId(Long goodsId) {
    return goodsMapper.findGoodsVoByGoodsId(goodsId);
}
```

```java
   <select id="findGoodsVoByGoodsId" resultType="com.chw.kill.vo.GoodsVo">
       select
g.id,g.goods_name,g.goods_title,g.goods_img,g.goods_detail,g.goods_price,g.goods_stock,
tg.kill_price,tg.stock_count,tg.start_date,tg.end_date
   from
   t_goods g
   left join t_kill_goods tg on g.id=tg.goods_id
   where g.id=#{goodsId}
   </select>
```

### 秒杀倒计时处理

开始时间处理

```html
<td>秒杀开始时间</td>
<td th:text="${#dates.format(goods.startDate, 'yyyy-MM-dd HH:mm:ss')}"></td>
```

秒杀倒计时与按钮

```html
<td id="killTip">
    <input type="hidden" id="remainSeconds" th:value="${remainSeconds}"/>
    <span th:if="${killState eq 0}">秒杀倒计时：<span id="countDown" th:text="${remainSeconds}"></span>秒</span>
    <span th:if="${killState eq 1}">秒杀进行中:</span>
    <span th:if="${killState eq 2}">秒杀已结束</span>
</td>
<script>
 $(function () {
        countDown();
    });

    function countDown() {
        var remainSeconds = $("#remainSeconds").val();
        var timeout;  //定时器
        if (remainSeconds > 0) {//秒杀还没开始，倒计时
            $("#buyButton").attr("disabled", true);
            timeout = setTimeout(function () {
                $("#countDown").text(remainSeconds - 1);
                $("#remainSeconds").val(remainSeconds - 1);
                countDown();
            }, 1000);
        } else if (remainSeconds == 0 ) {//秒杀进行中
            $("#buyButton").attr("disabled", false);
            if(timeout){
                clearTimeout(timeout);
            }
            $("#killTip").html("秒杀进行中");
        } else {//秒杀已经结束
            $("#buyButton").attr("disabled", true);
            $("#killTip").html("秒杀已经结束");
        }
    }
</script>
```

由商品ID查询商品详情

```java
@RequestMapping("toDetail/{goodsId}")
public String toDetail(Model model,User user, @PathVariable Long goodsId){
    model.addAttribute("user",user);
    GoodsVo goodsVo = goodsService.findGoodsVoByGoodsId(goodsId);
    Date startDate =goodsVo.getStartDate();
    Date endDate=goodsVo.getEndDate();
    Date nowDate=new Date();
    System.out.println(nowDate);
    int killState=0;
    int remainSeconds;  //还有多长时间开始秒杀
    if(nowDate.before(startDate)){
        remainSeconds= (int) ((startDate.getTime()-nowDate.getTime())/1000);
    }else if(nowDate.after(endDate)){
        killState=2;
        remainSeconds=-1;
    }else{
        killState=1;
        remainSeconds=0;
    }
    model.addAttribute("goods",goodsVo);
    model.addAttribute("killState",killState);
    model.addAttribute("remainSeconds",remainSeconds);
    return "goodsDetail";
}
```

点击秒杀后跳入订单详情页，判断是否有库存和限购一件

```java
/**
 * @Description: 秒杀
 * @param: [model, user, goodsId]
 * @return: java.lang.String
 * @date: 2021/6/10 20:58
 */
@RequestMapping("doKill")
public String doKill(Model model, User user,Long goodsId){
    if(user==null){
        return "login";
    }
    model.addAttribute("user",user);
    GoodsVo goods=goodsService.findGoodsVoByGoodsId(goodsId);
    //判断库存
    if(goods.getStockCount()< 1 ){
        model.addAttribute("errmsg", RespBeanEnum.EMPTY_STOCK.getMessage());
        return "doKillFail";
    }
    //判断是否重复抢购
    //Mybatis-plus写法
    KillOrder killOrder=killOrderService.getOne(new QueryWrapper<KillOrder>().eq("user_id",user.getId()).eq("goods_id",goodsId));
    System.out.println(killOrder);
    if(killOrder!=null){
        model.addAttribute("errmsg",RespBeanEnum.REPEATE_ERROR.getMessage());
        return "doKillFail";
    }
    Order order=killOrderService.doKill(user,goods);
    model.addAttribute("order",order);
    model.addAttribute("goods",goods);
    return "orderDetail";
}
```

```java
/**
 * @Description: 生成订单与秒杀订单
 * @param: [user, goods]
 * @return: com.chw.kill.domain.Order
 * @date: 2021/6/10 23:01
 */
@Override
public Order doKill(User user, GoodsVo goods) {
   KillGoods killGoods= killGoodsService.getOne(new QueryWrapper<KillGoods>().eq("goods_id",goods.getId()));
   killGoodsService.updateById(killGoods);
   //生成订单
   Order order=new Order();
   order.setUserId(user.getId());
   order.setGoodsId(goods.getId());
   order.setDeliverAddId(0L);
   order.setGoodsName(goods.getGoodsName());
   order.setGoodsCount(1);
   order.setGoodsPrice(killGoods.getKillPrice());
   order.setOrderChannel(1);
   order.setStatus(0);
   order.setCreateDate(new Date());
   orderMapper.insert(order);
   //生成秒杀订单
    KillOrder killOrder=new KillOrder();
    killOrder.setUserId(user.getId());
    killOrder.setOrderId(order.getId());
    killOrder.setGoodsId(goods.getId());
    killOrderService.save(killOrder);
    return order;
}
```

### JMeter压测

QPS(Queries Per Second)
是**每秒查询率**，是一台服务器每秒能够相应的查询次数，即1秒内完成的请求数量，是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准

TPS(TransactionsPerSecond)
也就是**事物数/秒**。它是软件测试结果的测量单位。一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数

下载JMeter，解压后在jmeter.propertires修改language 和字符属性为 zh_CN 和UTF-8 

在bin目录打开jmeter.bat

![image-20210611125420058](/../kill/pictures/image-20210611125420058.png)

填写HTTP请求默认值，线程组-》取样器-》HTTP请求，改名为商品列表，填写路径

### 缓存

QPS最大瓶颈在于数据库的操作。

使用的thymeleaf模板，每次浏览器请求，都要从服务器端获取到数据拼接成模板渲染返回给浏览器，即使加了缓存，中间传输的还是整个模板引擎。所以要做页面静态化，前端就是HTML，动态数据才有服务端传给浏览器

缓存页面与对象，进行静态化

#### 页面缓存

```java
/**
 * @Description: 商品列表页
 * @param: [model, user, request, response]
 * @return: java.lang.String
 * @date: 2021/6/12 20:57
 */
@RequestMapping(value="/toList",produces = "text/html;charset=utf-8")
@ResponseBody   //返回相应对象
public String toList(Model model,User user,HttpServletRequest request,HttpServletResponse response){
    model.addAttribute("user",user);
    model.addAttribute("goodsList",goodsService.findGoodsVo());
    //Redis中获取页面，如果不为空，直接返回页面
    ValueOperations valueOperations=redisTemplate.opsForValue();
    String html= (String) valueOperations.get("goodsList");
    if(!StringUtils.isEmpty(html)){
        return html;
    }
    //如果为空，手动渲染，存入Redis并返回
    WebContext webContext=new WebContext(request,response,request.getServletContext(),request.getLocale(),model.asMap());
    //获取引擎，获取模板名称，页面内容。手动渲染页面。
    html=thymeleafViewResolver.getTemplateEngine().process("goodsList",webContext);
    if(!StringUtils.isEmpty(html)){
        valueOperations.set("goodsList",html,60, TimeUnit.SECONDS);
    }
    //return "goodsList";
    return html;
}
```

手动渲染的页面，就是页面缓存

![image-20210612210044935](/../kill/pictures/image-20210612210044935.png)

#### URL缓存

```java
@RequestMapping(value = "toDetail/{goodsId}",produces = "text/html;charset=utf-8")
@ResponseBody
public String toDetail(Model model,User user, @PathVariable Long goodsId,HttpServletRequest request,HttpServletResponse response){
    model.addAttribute("user",user);
    GoodsVo goodsVo = goodsService.findGoodsVoByGoodsId(goodsId);
    Date startDate =goodsVo.getStartDate();
    Date endDate=goodsVo.getEndDate();
    Date nowDate=new Date();
    System.out.println(nowDate);
    int killState=0;
    int remainSeconds;  //还有多长时间开始秒杀
    if(nowDate.before(startDate)){
        remainSeconds= (int) ((startDate.getTime()-nowDate.getTime())/1000);
    }else if(nowDate.after(endDate)){
        killState=2;
        remainSeconds=-1;
    }else{
        killState=1;
        remainSeconds=0;

    }
    model.addAttribute("goods",goodsVo);
    model.addAttribute("killState",killState);
    model.addAttribute("remainSeconds",remainSeconds);

    ValueOperations valueOperations=redisTemplate.opsForValue();
    //从Redis中获取页面，如果不为空，直接返回页面
    String html= (String) valueOperations.get("goodsDetail:"+goodsId);
    if(!StringUtils.isEmpty(html)){
        return html;
    }
    WebContext webContext=new WebContext(request,response,request.getServletContext(),request.getLocale(),model.asMap());
    html=thymeleafViewResolver.getTemplateEngine().process("goodsDetail",webContext);
    if(!StringUtils.isEmpty(html)){
        valueOperations.set("goodsDetail:"+goodsId,html,60,TimeUnit.SECONDS);
    }
    //return "goodsDetail";
    return html;
}
```

![image-20210612211602088](/../kill/pictures/image-20210612211602088.png)

#### 对象缓存

在解决分布式情况下用户不一致问题时进行了对象缓存

存在redis中的用户永不失效，如果用户变更，redis不做处理会与数据库数据不一致，

```java
/**
 * @Description: 更新密码，演示用户更新时redis中的操作，未用到
 * @param: [userTicket, password, request, response]
 * @return: com.chw.kill.result.RespBean
 * @date: 2021/6/12 21:56
 */
public RespBean updatePassword(String userTicket,String password,HttpServletRequest request,HttpServletResponse response){
    User user=getUserByCookie(userTicket,request,response);
    if(user==null){
        throw new GlobalException(RespBeanEnum.MOBILE_NOT_EXIST);
    }
    user.setPassword(MD5Util.inputPassToDBPass(password,user.getSalt()));
    int result=userMapper.updateById(user);
    if(1==result){
        //删除redis中数据
        redisTemplate.delete("user"+userTicket);
        return RespBean.success();
    }
    return RespBean.error(RespBeanEnum.PASSWORD_UPDATE_FAIL);
}
```

#### 页面静态化

静态化详情页面

static/goodsDetail.htm

处理后端接口，返回公共对象detailVo，主要在于thymeleaf模板换成了htm的静态页面进行跳转，通过ajax获取静态数据手动渲染

```html
<!DOCTYPE HTML>
<html >
<head>
    <title>商品详情</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <!-- jquery -->
    <script type="text/javascript" src="/js/jquery.min.js"></script>
    <!-- bootstrap -->
    <link rel="stylesheet" type="text/css" href="/bootstrap/css/bootstrap.min.css" />
    <script type="text/javascript" src="/bootstrap/js/bootstrap.min.js"></script>
    <!-- jquery-validator -->
    <script type="text/javascript" src="/jquery-validation/jquery.validate.min.js"></script>
    <script type="text/javascript" src="/jquery-validation/localization/messages_zh.min.js"></script>
    <!-- layer -->
    <script type="text/javascript" src="/layer/layer.js"></script>
    <!-- md5.js -->
    <script type="text/javascript" src="/js/md5.min.js"></script>
    <!-- common.js -->
    <script type="text/javascript" src="/js/common.js"></script>
</head>
<body>

<div class="panel panel-default">
    <div class="panel-heading">秒杀商品详情</div>
    <div class="panel-body">
        <span id="userTip"> 您还没有登录，请登陆后再操作<br/></span>
    </div>
    <table class="table" id="goodslist">
        <tr>
            <td>商品名称</td>
            <td colspan="3" id="goodsName"></td>
        </tr>
        <tr>
            <td>商品图片</td>
            <td colspan="3"><img  id="goodsImg" width="200" height="200" /></td>
        </tr>
        <tr>
            <td>秒杀开始时间</td>
            <td id="startTime"></td>
            <td >
                <input type="hidden" id="remainSeconds" />
                <span id="killTip"></span>
            </td>
            <td>

                <button class="btn btn-primary btn-block" type="button" id="buyButton" onclick="dokill()">立即秒杀
                    <input type="hidden" name="goodsId"  id="goodsId" />
                </button>
            </td>
        </tr>
        <tr>
            <td>商品原价</td>
            <td colspan="3" id="goodsPrice"></td>
        </tr>
        <tr>
            <td>秒杀价</td>
            <td colspan="3"  id="killPrice"></td>
        </tr>
        <tr>
            <td>库存数量</td>
            <td colspan="3"  id="stockCount"></td>
        </tr>
    </table>
</div>
</body>

<script>
    $(function () {
        getDetails();
    });

    function getDetails() {
       var goodsId= g_getQueryString("goodsId");
       $.ajax({
           url:'/goods/detail/'+goodsId,
           type:'GET',
           success:function (data) {
                if(data.code==200){
                    render(data.obj);
                }else{
                    layer.msg("客户端请求出错")
                }
           },
           error:function () {
               layer.msg("客户端请求失败");
           }
       });
    }

    function dokill() {
        $.ajax({
            url:'/killGoods/dokill',
            type:'POST',
            data:{
              goodsId:$("#goodsId").val()
            },
            success:function (data) {
                if(data.code==200){
                    window.location.href="/orderDetail.htm?orderId="+data.obj.id;
                }else{
                    layer.msg(data.message)
                }
            },
            error:function () {
                layer.msg("客户端请求失败");
            }
        });
    }

    function render(detail) {
        /*var killStatus = detail.killStatus;*/
        var user = detail.user;
        var goods = detail.goodsVo;
        var remainSeconds = detail.remainSeconds;
        if (user) {
            $("#userTip").hide();
        }
        $("#goodsName").text(goods.goodsName);
        $("#goodsImg").attr("src", goods.goodsImg);
        $("#startTime").text(new Date(goods.startDate).format("yyyy-MM-dd hh:mm:ss"));
        $("#remainSeconds").val(remainSeconds);
        $("#goodsId").val(goods.id);
        $("#goodsPrice").text(goods.goodsPrice);
        $("#killPrice").text(goods.killPrice);
        $("#stockCount").text(goods.stockCount);
        countDown();
    }

    function countDown() {
        var remainSeconds = $("#remainSeconds").val();
        var timeout;  //定时器
        if (remainSeconds > 0) {//秒杀还没开始，倒计时
            $("#buyButton").attr("disabled", true);
            $("#killTip").html("秒杀倒计时"+remainSeconds+"秒");
            timeout = setTimeout(function () {
                //$("#countDown").text(remainSeconds - 1);
                $("#remainSeconds").val(remainSeconds - 1);
                countDown();
            }, 1000);
        } else if (remainSeconds == 0 ) {//秒杀进行中
            $("#buyButton").attr("disabled", false);
            if(timeout){
                clearTimeout(timeout);
            }
            $("#killTip").html("秒杀进行中");
        } else {//秒杀已经结束
            $("#buyButton").attr("disabled", true);
            $("#killTip").html("秒杀已经结束");
        }
    }
</script>
</html>
```

```java
/**
 * @Description: 秒杀静态化
 * @param: [model, user, goodsId]
 * @return: com.chw.kill.result.RespBean
 * @date: 2021/6/13 11:04
 */
@RequestMapping(value="dokill",method = RequestMethod.POST)
@ResponseBody
public RespBean dokill( User user, Long goodsId){
    if(user==null){
        return RespBean.error(RespBeanEnum.SESSION_ERROR);
    }
    GoodsVo goods=goodsService.findGoodsVoByGoodsId(goodsId);
    //判断库存
    if(goods.getStockCount()< 1 ){
        return RespBean.error(RespBeanEnum.EMPTY_STOCK);
    }
    //判断是否重复抢购
    //Mybatis-plus写法
    KillOrder killOrder=killOrderService.getOne(new QueryWrapper<KillOrder>().eq("user_id",user.getId()).eq("goods_id",goodsId));
    System.out.println(killOrder);
    if(killOrder!=null){
        return RespBean.error(RespBeanEnum.REPEATE_ERROR);
    }
    Order order=killOrderService.doKill(user,goods);
    return RespBean.success(order);
}
```

配置静态资源静态化处理

```java
#启动默认静态资源处理，默认启用
spring.web.resources.add-mappings=true
#缓存相应时间，单位秒
spring.resources.cache.cachecontrol.max-age=3600
#资源链启动缓存，默认启动
spring.resources.chain.cache=true
#启用资源链，默认禁用
spring.resources.chain.enabled=true
#启用资源压缩（gzip，brotli）解析，默认禁用
spring.resources.chain.compressed=true
#启用h5应用缓存，默认禁用
spring.resources.chain.html-application-cache=true
spring.resources.static-locations:classpath:/static/
```

火狐浏览器，已缓存状态

![image-20210613133619554](/../kill/pictures/image-20210613133619554.png)

#### 订单静态化

```html
<!DOCTYPE HTML>
<html>
<head>
    <title>订单详情</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <!-- jquery -->
    <script type="text/javascript" src="/js/jquery.min.js"></script>
    <!-- bootstrap -->
    <link rel="stylesheet" type="text/css" href="/bootstrap/css/bootstrap.min.css" />
    <script type="text/javascript" src="/bootstrap/js/bootstrap.min.js"></script>
    <!-- jquery-validator -->
    <script type="text/javascript" src="/jquery-validation/jquery.validate.min.js"></script>
    <script type="text/javascript" src="/jquery-validation/localization/messages_zh.min.js"></script>
    <!-- layer -->
    <script type="text/javascript" src="/layer/layer.js"></script>
    <!-- md5.js -->
    <script type="text/javascript" src="/js/md5.min.js"></script>
    <!-- common.js -->
    <script type="text/javascript" src="/js/common.js"></script>
</head>
<body>
<div class="panel panel-default">
    <div class="panel-heading">秒杀订单详情</div>
    <table class="table" id="goodslist">
        <tr>
            <td>商品名称</td>
            <td colspan="3" id="goodsName"></td>
        </tr>
        <tr>
            <td>商品图片</td>
            <td colspan="2"><img  id="goodsImg" width="200" height="200" /></td>
        </tr>
        <tr>
            <td>订单价格</td>
            <td colspan="2"  id="orderPrice"></td>
        </tr>
        <tr>
            <td>下单时间</td>
            <td id="createDate" colspan="2"></td>
        </tr>
        <tr>
            <td>订单状态</td>
            <td id="orderStatus">
            </td>
            <td>
                <button class="btn btn-primary btn-block" type="submit" id="payButton">立即支付</button>
            </td>
        </tr>
        <tr>
            <td>收货人</td>
            <td colspan="2">XXX  18812341234</td>
        </tr>
        <tr>
            <td>收货地址</td>
            <td colspan="2">北京市昌平区回龙观龙博一区</td>
        </tr>
    </table>
</div>
<script>
    $(function () {
        getOrderDetail();
    });

    function getOrderDetail() {
       var orderId=g_getQueryString("orderId");
       $.ajax({
           url:'/order/detail',
           type:'GET',
           data:{
               orderId:orderId
           },
           success:function (data) {
               if(data.code==200){
                   render(data.obj);
               }else{
                   layer.msg(data.message)
               }
           },
           error:function () {
               layer.msg("客户端请求失败")
           }
       })
    }
    function render(detail) {
        var goods=detail.goodsVo;
        var order=detail.order;
        $("#goodsName").text(goods.goodsName);
        $("#goodsImg").attr("src",goods.goodsImg);
        $("#orderPrice").text(order.goodsPrice);
        $("#createDate").text(new Date(order.createDate).format("yyyy-MM-dd hh:mm:ss"))
        var status=order.status;
        var statusText="";
        switch (status) {
            case 0:
                statusText="未支付";
                break;
            case 1:
                statusText="待发货";
                break;
            case 2:
                statusText="已发货";
                break;
            case 3:
                statusText="已收货";
                break;
            case 4:
                statusText="已退款";
                break;
            case 5:
                statusText="已完成";
                break;
        }
        $("#orderStatus").text(statusText);
    }
    
</script>

</body>
</html>
```

```java
/**
 * @Description: 订单详情
 * @param: [user, orderId]
 * @return: com.chw.kill.result.RespBean
 * @date: 2021/6/13 14:34
 */
@RequestMapping("/detail")
@ResponseBody
public RespBean detail(User user,Long orderId){
    if(user==null){
        return RespBean.error(RespBeanEnum.SESSION_ERROR);
    }
    OrderDetailVo detailVo=orderService.getDetail(orderId);
    return RespBean.success(detailVo);
}
```

```java
/**
 * @Description: 订单详情
 * @param: [orderId]
 * @return: com.chw.kill.vo.OrderDetailVo
 * @date: 2021/6/13 13:53
 */
@Override
public OrderDetailVo getDetail(Long orderId) {
    if(orderId==null){
        throw new GlobalException(RespBeanEnum.ORDER_NOT_EXIST);
    }
    Order order=orderMapper.selectById(orderId);
    GoodsVo goodsVo=goodsService.findGoodsVoByGoodsId(order.getGoodsId());
    OrderDetailVo detailVo=new OrderDetailVo();
    detailVo.setOrder(order);
    detailVo.setGoodsVo(goodsVo);
    return detailVo;
}
```

### 解决库存超卖

判断库存大于0，使用sql语句进行减库存

```java
//设置库存同时确保ID是更新的商品ID，gt确保库存大于0；
boolean killGoodsResult=killGoodsService.update(new UpdateWrapper<KillGoods>().
        setSql("stock_count=stock_count-1").eq("goods_id",goods.getId()).gt("stock_count",0));
if(!killGoodsResult){
            return null;
        }
//信息存入redis
        redisTemplate.opsForValue().set("order"+user.getId()+":"+goods.getId(),killOrder);
```

添加索引，解决同一用户下单多个商品

![image-20210613183111299](/../kill/pictures/image-20210613183111299.png)

KillGoodsController，从redis获取订单并判断

```java
//判断是否重复抢购
KillOrder killOrder= (KillOrder) redisTemplate.opsForValue().get("order:"+user.getId()+":"+goodsId);
```

### 接口优化方向

Redis预减库存，减少数据库访问，进行内存标记，优化Redis访问，请求进入队列，进行异步下单

#### Redis预减库存

通过实现InitializingBean中的方法，将商品数量加载到Redis

```java
/**
 * @Description: 初始化时会执行的方法
 *
 * 系统初始化，把商品数量加载到Redis
 * @param: []
 * @return: void
 * @date: 2021/6/17 19:59
 */
@Override
public void afterPropertiesSet() throws Exception {
    List<GoodsVo> list=goodsService.findGoodsVo();
    if(CollectionUtils.isEmpty(list)){ //判断list是否未空
        return;
    }
    //不为空存入redis
    list.forEach(goodsVo -> redisTemplate.opsForValue().set("killGoods:"+goodsVo.getId(),goodsVo.getStockCount()));
}
```

通过Redis进行扣减库存，如果不够直接返回，够则使用RabbitMQ

封装了一个消息对象，通过RabbitMQ发送这个消息对象，在Receive的监听里收到消息

因为使用了RabbitMQ，原先的流程基本不变，但是变成了异步的操作。可以快速的返回请求，进行流量削峰的作用。

```java
return RespBean.success(0);
```

0是返回排队中，下单时先返回排队中，轮询获取是否下单成功

#### Redis分布式锁

```java
//测试类中实现，测试分布式锁
@SpringBootTest
public class KillApplicationTests {

    @Autowired
    private RedisTemplate redisTemplate;

    @Autowired
    private RedisScript<Boolean> script;

    @Test
    public  void Test01() {
        ValueOperations valueOperations = redisTemplate.opsForValue();
        //占位，如果k不存在可以设置成功
        Boolean isLock=valueOperations.setIfAbsent("k1","v1");
        //如果占位成功，进行正常操作
        if(isLock){
            valueOperations.set("name","xxx");
            String name= (String) valueOperations.get("name");
            System.out.println("name=" +name);
            //Integer.parseInt("xxx");  //抛出异常则删锁失败，线程被占用,解决方法：设置过期时间
            //操作结束，删除锁
            //redisTemplate.delete("k1");
        }else{
            System.out.println("线程正在使用");
        }
    }
    @Test
    public void Test02() {
        ValueOperations valueOperations = redisTemplate.opsForValue();
        //添加过期时间，防止应用在运行过程中抛出异常导致锁无法释放
        Boolean isLock=valueOperations.setIfAbsent("k1","v1",5, TimeUnit.SECONDS);
        //可以获取锁，但是会造成其他影响，可能删除下一个线程的锁，导致紊乱
        if(isLock){
            valueOperations.set("name","xxx");
            String name= (String) valueOperations.get("name");
            System.out.println("name=" +name);
            Integer.parseInt("xxx");  //会抛异常
            //操作结束，删除锁
            //redisTemplate.delete("k1");
        }else{
            System.out.println("线程正在使用");
        }
    }

    //所以给value一个随机值，先获取到锁，再判断锁的值是否一致。一致才删除
    //这三个操作不是原子性的，所以使用lua脚本实现，同时也减少了网络传输。两种写法：1.通过服务器写好，不好修改2.通过java传输，增加网络消耗

    @Test
    public void Test03() {
        ValueOperations valueOperations = redisTemplate.opsForValue();
        String value= UUID.randomUUID().toString();
        Boolean isLock=valueOperations.setIfAbsent("k1",value,5, TimeUnit.SECONDS);
        if(isLock){
            valueOperations.set("name","xxx");
            String name= (String) valueOperations.get("name");
            System.out.println("name=" +name);
            System.out.println(valueOperations.get("k1"));
            Boolean result=(Boolean) redisTemplate.execute(script, Collections.singletonList("k1"),value);
            System.out.println(result);
        }else{
            System.out.println("线程正在使用");
        }
    }

}

```

redisConfig中

```java
@Bean
public DefaultRedisScript<Boolean> script(){
    DefaultRedisScript<Boolean> redisScript=new DefaultRedisScript<>();
    //lock.lua脚本位置和application.yml同级目录
    redisScript.setLocation(new ClassPathResource("lock.lua"));
    redisScript.setResultType(Boolean.class);
    return redisScript;
}
```

lua脚本文件

```lua
if redis.call("get",KEYS[1])==ARGV[1] then
    return redis.call("del",KEYS[1])
else
    return 0
end
```

实现预减库存

脚本文件

```lua
if(redis.call("exists", KEYS[1])==1) then
    local stock = tonumber(redis.call("get", KEYS[1]));
    if(stock>0) then
        redis.call("incrby",KEYS[1],-1);
        return stock;
    end;
        return 0;
end;
```

配置中

```java
@Bean
public DefaultRedisScript<Long> script(){
    DefaultRedisScript<Long> redisScript=new DefaultRedisScript<>();
    redisScript.setLocation(new ClassPathResource("stock.lua"));
    redisScript.setResultType(Long.class);
    return redisScript;
}
```

```java
 //预减库存     redis中的递减，原子性
 //Long stock= valueOperations.decrement("killGoods:"+goodsId);
Long stock= (Long) redisTemplate.execute(script, Collections.singletonList("killGoods:"+goodsId),Collections.EMPTY_LIST);
```

#### 服务优化总结

最终目的都是减少数据库访问，在系统初始化时加载商品数量到redis中，收到秒杀请求时用redis预减库存，库存不足直接返回，否则将请求进入队列，返回排队中，队列中消息被消费者监听进行消费时，就会去生成订单，减少库存，之后客户端轮询看是否真的下单成功。

接口优化：通过实现InitializingBean接口中的afterPropertiesSet方法，使库存在初始化时加载到redis中，通过redis预购库存，扣除成功通过rabbitMQ发送过去进行异步下单操作，快速响应返回排队中，客户端不停轮询获取是否真正下单成功，redis预减库存后，没有库存清空下，仍会频繁访问redis，所以进行内存标记确定是否要访问redis，除了使用redis递减递增预减库存，最终使用分布式锁，使用lua脚本确保原子性（应放在服务器端，网络交互少，QPS高）

#### 秒杀地址的隐藏

点击秒杀按钮，获取的是真正秒杀的接口地址，不访问数据库，再跳转地址访问数据库就耗时增加，为前期并发有帮助

```javascript
function getkillPath() {
    var goodsId=$("#goodsId").val();
    var captcha=$("#captcha").val();
    g_showLoading();
    $.ajax({
        url:"/killGoods/path",
        type:"GET",
        data:{
            goodsId:goodsId,
            captcha:captcha
        },
        success:function (data) {
            if(data.code==200){
                var path=data.obj;
                dokill(path)
            }else{
                layer.msg(data.message)
            }
        },
        error:function (data) {
            layer.msg("客户端请求失败")
        }
    })
}
```

```java
@Override
public boolean checkPath(User user, Long goodsId,String path) {
    if(user==null|| goodsId<0 || StringUtils.isEmpty(path)){
        return false;
    }
    String redisPath= (String) redisTemplate.opsForValue().get("killPath"+user.getId()+":"+goodsId);
    return path.equals(redisPath);
}
```

#### 生成验证码

添加依赖

```java
<!--验证码依赖-->
<dependency>
    <groupId>com.github.whvcse</groupId>
    <artifactId>easy-captcha</artifactId>
    <version>1.6.2</version>
</dependency>
```

获取验证码

```java
@RequestMapping(value = "/captcha",method = RequestMethod.GET)
public void verifyCode(User user, Long goodsId, HttpServletResponse response){
    if(user==null || goodsId<0){
        throw new GlobalException(RespBeanEnum.REQUEST_ILLEGAL);
    }
    //设置请求头为输出图片的类型
    response.setContentType("image/jpg");
    response.setHeader("Pargam","No-cache");
    response.setDateHeader("Expires",0);
    //生成验证码，将结果放入Redis
    ArithmeticCaptcha captcha=new ArithmeticCaptcha(130,32,3);
    redisTemplate.opsForValue().set("captcha:"+user.getId()+":"+goodsId,captcha.text(),300, TimeUnit.SECONDS);
    try {
        captcha.out(response.getOutputStream());
    } catch (IOException e) {
        log.info("验证码生成失败",e.getMessage());
    }
}
```

```java
/**

 * @Description: 获取秒杀地址
 * @param: [user, path]
 * @return: com.chw.kill.result.RespBean
 * @date: 2021/6/18 21:23
   */
   @AccessLimit(second=5,maxCount=5,needLogin=true) //通用接口限流
   @RequestMapping(value = "/path",method = RequestMethod.GET)
   @ResponseBody
   public RespBean path(User user, Long goodsId, String captcha, HttpServletRequest request){
   if (user==null){
       return RespBean.error(RespBeanEnum.SESSION_ERROR);
   }
   //判断验证码
   boolean check=killOrderService.checkCaptcha(user,goodsId,captcha);
   if(!check){
       return RespBean.error(RespBeanEnum.ERROR_CAPTCHA);
   }
   String str=killOrderService.createPath(user,goodsId);
   return RespBean.success(str);
   }
```

启动项目在商品详情页秒杀商品进入订单页面再返回或停留在商品详情页面再次输入验证码进行秒杀会出现错误

后台报错，RabbitMQ一直发送信息，导致一直访问Redis和数据库，服务器压力过大。需要删除消息队列才停止

查询后发现是存入redis的订单号信息和要取的订单号信息不一致，无法判断重购，导致重复进行秒杀，RabbitMQ持续发送消息创建新订单

#### 简单接口限流

限制流量，缓解服务器压力，保护系统

使用**计数器算法**，请求一次计数器加1，一分钟之内到达请求阈值则禁止请求，定时清零

如果限制QPS=100 每分钟，那么最大访问QPS在150左右

临界问题：到达一分钟前后分别进行100次访问，短短的时间请求200次，会把服务器撑爆

浪费资源：前30s处理完100次请求后面服务器空闲，浪费资源

**漏桶算法**：水龙头滴水，下面漏水，滴的水就是请求，漏的水就是放行的请求，

缺点：因为漏水这个操作相当于做了流量控制，水龙头开大（请求过快过大），容易把桶装满然后失效，服务器撑爆。一般用队列机制处理

漏的水多滴的水少就造成资源浪费，请求跟不上放行速度。

**令牌桶算法**：恒定速度生成令牌，会访问令牌桶是否装满，装满就放弃进入否则进入令牌桶。请求过来也会从桶里拿请求，判断是否拿到，拿到就进行业务处理，没拿到就丢弃或执行失败处理

恒定速度生成令牌，在真正秒杀前令牌桶是满的，可以应对短暂的大量请求，令牌拿完之后还是恒定的放入令牌。

漏桶更多是保护他人，令牌桶是保护自己，将请求压力交给目标服务器处理



获取秒杀地址时进行接口限流

```java
 //简单接口限流
   ValueOperations valueOperations=redisTemplate.opsForValue();
   //限制访问次数。5秒内访问5次
   String uri=request.getRequestURI();
   captcha="0"; //不用算
   Integer count= (Integer) valueOperations.get(uri+":"+user.getId());
   if(count==null){
       valueOperations.set(uri+":"+user.getId(),1,5,TimeUnit.SECONDS);
   }else if(count<5){
       valueOperations.increment(uri+":"+user.getId());
   }else {
       return RespBean.error(RespBeanEnum.ACCESS_LIMIT_REAHCED);
   }
```

#### 通用接口限流

使用注解

```java
@AccessLimit(second=5,maxCount=5,needLogin=true) //通用接口限流
```

```java
/**
 * @Author
 * @Description  通用限流注解
 * @Date 2021/6/18 23:46
 */

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface AccessLimit {
    int second();
    int maxCount();
    boolean needLogin() default true;
}
```

```java
/**
 * @Author Chihw
 * @Description
 * @Date 2021/6/18 23:51
 */
@Component
public class AccessLimitInterceptor implements HandlerInterceptor {
    @Autowired
    private IUserService userService;
    @Autowired
    private RedisTemplate redisTemplate;

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        if(handler instanceof HandlerMethod){
            User user=getUser(request,response);
            UserContext.setUser(user);
            HandlerMethod hm = (HandlerMethod) handler;
            AccessLimit accessLimit=hm.getMethodAnnotation(AccessLimit.class);
            if(accessLimit==null){
                return true;
            }
            int second=accessLimit.second();
            int maxCount=accessLimit.maxCount();
            boolean needLogin=accessLimit.needLogin();
            String key=request.getRequestURI();
            if (needLogin){
                if (user==null){
                    render(response,RespBeanEnum.SESSION_ERROR);
                    return false;
                }
                key+=":"+user.getId();
            }
            ValueOperations valueOperations=redisTemplate.opsForValue();
            Integer count= (Integer) valueOperations.get(key);
            if (count==null){
                valueOperations.set(key,1,second, TimeUnit.SECONDS);
            }else if (count<maxCount){
                valueOperations.increment(key);
            }else {
                render(response,RespBeanEnum.ACCESS_LIMIT_REAHCED);
                return false;
            }
        }
        return true;
    }
    /**
     * @Description: 构建返回对象
     * @param: [response, error]
     * @return: void
     * @date: 2021/6/19 10:08
     */
    private void render(HttpServletResponse response, RespBeanEnum respBeanEnum) throws IOException {
        response.setContentType("application/json");
        response.setCharacterEncoding("UTF-8");
        PrintWriter out=response.getWriter();
        RespBean respBean=RespBean.error(respBeanEnum);
        out.write(new ObjectMapper().writeValueAsString(respBean));
        out.flush();
        out.close();
    }

    /**
     * @Description: 获取当前登录用户
     * @param: [request, response]
     * @return: com.chw.kill.domain.User
     * @date: 2021/6/19 9:58
     */
    private User getUser(HttpServletRequest request, HttpServletResponse response) {
        String ticket= CookieUtil.getCookieValue(request,"userticket");
        if(StringUtils.isEmpty(ticket)){
            return null;
        }
        return userService.getUserByCookie(ticket,request,response);
    }
}
```

```java
/**
 * @Author Chihw
 * @Description     让每个线程绑定自己的值，高并发多线程场景下。
 * 如果在公共线程里面存用户信息可能会造成用户信息的紊乱，所以当前登录的用户信息都存在自己的线程里
 * 避免线程安全问题
 * @Date 2021/6/19 9:59
 */
public class UserContext {

    private static ThreadLocal<User> userHolder=new ThreadLocal<>();

    public static void setUser(User user){
        userHolder.set(user);
    }

    public static User getUser(){
        return userHolder.get();

    }
}
```

#### 安全优化总结

隐藏秒杀地址

单独靠前端无法优化完成，http是明文的，可以获取到接口地址，可以短时间调用秒杀接口，使用验证码，拦截的一部分脚本，分散QPS，降低每秒承受的QPS。使用接口限流，用的是最简单的计数器算法，一定时间请求一定次数，到达时间后重置计数器，具有临界问题和资源浪费问题。最后进行接口限流，使用拦截器进行限流，配合自定义注解

## 总结

### 项目框架搭建

- SpringBoot环境搭建
- 集成Thymeleaf模板，RespBean返回对象
- Mybatis

### 分布式会话

- 用户登录
  1. 设计数据库
  2. 明文密码二次MD5加密
  3. 参数校验+全局异常处理
- 共享Session
  1. SpringSession
  2. Redis

### 功能开发

- 商品列表
- 商品详情
- 秒杀
- 订单详情

### 系统压测

- Jmeter
- 自定义变量模拟多用户
- Jmeter命令行的使用
- 压测商品列表和秒杀

### 页面优化

- 页面缓存+URL缓存+对象缓存
- 页面静态化，前后端分离
- 静态资源优化
- CDN优化

### 接口优化

- Redis预减库存减少数据库的访问
- 内存标记减少Redis的访问
- RabbitMQ异步下单
  - spring boot整合RabbitMQ
  - 交换机

### 安全优化

- 秒杀接口地址隐藏
- 算术验证码
- 接口防刷

### 主流秒杀方案分析

秒杀抢购系统需要注意的地方

- 高并发、刷接口等黑客请求对服务器端的负载冲击
- 高并发带来的超卖
- 高荷载情况下下单的数量和成功率的保障



### RabbitMQ

安装并使用springboot集成rabbitmq

```java
<!--amqp依赖-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-amqp</artifactId>
</dependency>
```

配置rabbitmq

```java
#RabbitMQ
#rabbitmq服务器
spring.rabbitmq.host=127.0.0.1
#用户名
spring.rabbitmq.username=
#密码
spring.rabbitmq.password=
#端口
spring.rabbitmq.port=5672
#spring.rabbitmq.virtual-host=/
#消费者最小数据
spring.rabbitmq.listener.simple.concurrency= 10
#消费者最大数量
spring.rabbitmq.listener.simple.max-concurrency= 10
#限制消费者每次只处理一条消息，处理完再继续下一条消息
spring.rabbitmq.listener.simple.prefetch= 1
#启动时是否默认自动启动，默认true
spring.rabbitmq.listener.simple.auto-startup=true
#被拒绝时重新进入队列
spring.rabbitmq.listener.simple.default-requeue-rejected= true
#发布重试，默认false
spring.rabbitmq.template.retry.enabled=true 
#发布时间，默认1000ms
spring.rabbitmq.template.retry.initial-interval=1000ms
#重试最大次数，默认3次
spring.rabbitmq.template.retry.max-attempts=3
#重试最大时间间隔，默认10000ms
spring.rabbitmq.template.retry.max-interval=10000ms
重试间隔系数，比如配2.0，第一次等10s，第二次20s，第三次等40s
spring.rabbitmq.template.retry.multiplier=1.0
```

准备队列

```java
/**
 * @Description: 准备队列
 * @param: []
 * @return: org.springframework.amqp.core.Queue
 * @date: 2021/6/13 21:50
 */
@Bean
public Queue queue(){
    //消息要不要持久化，队列配置为持久化才可以使消息持久化
    return new Queue("queue",true);
}
```

```java
/**
 * @Description: 消息生产者
 * @param: [msg]
 * @return: void
 * @date: 2021/6/13 21:51
 */
public void send(Object msg){
    log.info("发送消息"+msg);
    rabbitTemplate.convertAndSend("queue",msg);
}
```

```java
/**
 * @Description: 消息发送者
 * @param: [msg]
 * @return: void
 * @date: 2021/6/13 21:51
 */
@RabbitListener(queues="queue")
public void receive(Object msg){
    log.info("接收消息"+msg);
}
```

#### fanout模式

准备交换机，将队列与交换机绑定，发送一个消息到交换机，交换机就将消息发送给所有和他绑定的一个队列

#### direct模式

交换机与队列绑定时一定要添加路由key，发消息时也要有路由key，根据发送消息携带的路由key，和一开始交换机和队列绑定的路由key进行匹配，匹配到正常发出

#### Topic模式

主题模式

可以实现上面两个模式，注意通配符

#### Headers模式

不依赖于rountingKey，用headers匹配队列，键值对类型






